using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEditor.Build.Reporting;
using UnityEngine;

namespace NoirUnityEditor.Modifications.Preprocessors {
    //Note: This class uses UnityEditorInternal which is an undocumented internal feature    
    /// <summary>
    /// Creates c# code files that map back to various Unity asset types
    /// </summary>
    /// <seealso cref="UnityEditor.Build.IPreprocessBuildWithReport" />
    public class UnityCodeGenPreprocessor {
        /// <summary>
        /// The folder location under Assets/ to write the code files
        /// </summary>
        public const string FOLDER_LOCATION = "Scripts/AutoGenerated/";

        /// <summary>
        /// The file name for the auto generated Tags
        /// </summary>
        private const string TAGS_FILE_NAME = "Tags";

        /// <summary>
        /// The file name for the auto generated Layers
        /// </summary>
        private const string LAYERS_FILE_NAME = "Layers";

        /// <summary>
        /// The file name for the auto generated Scenes
        /// </summary>
        private const string SCENES_FILE_NAME = "Scenes";

        /// <summary>
        /// The file name for the auto generated SortingLayers
        /// </summary>
        private const string SORTING_LAYERS_FILE_NAME = "SortingLayers";
        /// <summary>
        /// The file extension for auto generated code files
        /// </summary>
        private const string SCRIPT_EXTENSION = ".cs";

        public int callbackOrder { get { return 0; } }
        public void OnPreprocessBuild(BuildReport report) {
            AutoGenerateCodeFiles();
            Debug.Log($"[{nameof(UnityCodeGenPreprocessor)}] for target {report.summary.platform} at path {report.summary.outputPath}.");
        }

        [MenuItem("Tools/TroubleCat Studios/Rebuild Tags, Layers and Scenes Classes")]
        [UnityEditor.Callbacks.DidReloadScripts]
        public static void AutoGenerateCodeFiles() {
            var startTime = DateTime.Now.Ticks;
            var folderPath = Application.dataPath + "/" + FOLDER_LOCATION;
            if (!Directory.Exists(folderPath)) {
                Directory.CreateDirectory(folderPath);
            }

            var labels = GetSortingLayerNames();
            var values = GetSortingLayerUniqueIDs();


            var fileGenerationWork = new List<(string FileName, string Contents)>();
            var generatedFiles = new List<string>();

            fileGenerationWork.Add((FileName: TAGS_FILE_NAME, Contents: GetClassContent(UnityEditorInternal.InternalEditorUtility.tags)));
            fileGenerationWork.Add((FileName: LAYERS_FILE_NAME, Contents: GetLayerClassContent(UnityEditorInternal.InternalEditorUtility.layers)));
            fileGenerationWork.Add((FileName: SCENES_FILE_NAME, Contents: GetClassContent(EditorBuildSettingsScenesToNameStrings(EditorBuildSettings.scenes))));
            fileGenerationWork.Add((FileName: SORTING_LAYERS_FILE_NAME, Contents: GetSortingLayerClassContent(labels, values)));

            foreach (var gen in fileGenerationWork) {
                var outputFile = folderPath + gen.FileName + SCRIPT_EXTENSION;
                var hash = GetHashString(gen.Contents);
                var previousHash = GetHashFromSourceFile(outputFile);
                if (hash != previousHash) {
                    Debug.Log($"[{nameof(UnityCodeGenPreprocessor)}] AutoGenerateCodeFiles - wrote: {outputFile}");
                    File.WriteAllText(outputFile, GetClassWrapper(gen.FileName, gen.Contents));
                    generatedFiles.Add($"Assets/{FOLDER_LOCATION}{gen.FileName}{SCRIPT_EXTENSION}");
                } else {
                    Debug.Log($"[{nameof(UnityCodeGenPreprocessor)}] AutoGenerateCodeFiles - skipped (hash match): {outputFile}");
                }
            }

            foreach (var file in generatedFiles) {
                Debug.Log($"[{nameof(UnityCodeGenPreprocessor)}] AutoGenerateCodeFiles - re-importing: {file}");
                AssetDatabase.ImportAsset(file, ImportAssetOptions.ForceUpdate);
            }

            var generationTime = new TimeSpan(DateTime.Now.Ticks - startTime);
            Debug.Log($"[{nameof(UnityCodeGenPreprocessor)}] AutoGenerateCodeFiles - Generation Complete. {generationTime.TotalSeconds}s");
        }

        private static string GetNamespace() {
            var settings = NoirEditorSettings.GetOrCreateSettings();
            return settings.CodeGeneratorNamespace;
        }

        // Get the sorting layer names
        private static string[] GetSortingLayerNames() {
            var internalEditorUtilityType = typeof(UnityEditorInternal.InternalEditorUtility);
            var sortingLayersProperty = internalEditorUtilityType.GetProperty("sortingLayerNames", BindingFlags.Static | BindingFlags.NonPublic);
            return (string[])sortingLayersProperty.GetValue(null, new object[0]);
        }
        // Get the unique sorting layer IDs -- tossed this in for good measure
        private static int[] GetSortingLayerUniqueIDs() {
            var internalEditorUtilityType = typeof(UnityEditorInternal.InternalEditorUtility);
            var sortingLayerUniqueIDsProperty = internalEditorUtilityType.GetProperty("sortingLayerUniqueIDs", BindingFlags.Static | BindingFlags.NonPublic);
            return (int[])sortingLayerUniqueIDsProperty.GetValue(null, new object[0]);
        }

        private static string[] EditorBuildSettingsScenesToNameStrings(EditorBuildSettingsScene[] scenes) {
            return scenes
                .Select(s => System.IO.Path.GetFileNameWithoutExtension(s.path))
                .TakeWhile(s => !string.IsNullOrWhiteSpace(s))
                .ToArray();
        }

        private static string GetClassWrapper(string className, string contents) {
            string output = $"namespace {GetNamespace()} {{\n";
            output += "    using System.Collections.Generic;\n";
            output += $"    // This class is auto-generated do not modify. (Build by {nameof(UnityCodeGenPreprocessor)}.cs)\n";
            output += $"    // Last Generated: {DateTime.Now.ToString()}\n";
            output += $"    // Content hash: {GetHashString(contents)}\n";
            output += $"    public class {className}{{\n";
            output += contents;
            output += "\n    }\n";
            output += "}";
            return output;
        }

        private static string GetClassContent(string[] labelsArray) {
            var output = "";
            var list = new StringBuilder();
            list.AppendLine($"\t\tpublic static List<string> All = new List<string>() {{");
            foreach (var label in labelsArray) {
                output += $"\t\t{BuildConstVariable(label)}\n";
                list.AppendLine($"\t\t\t\"{label}\",");
            }
            list.AppendLine($"\t\t}};");
            output += list.ToString();
            return output;
        }

        private static string GetClassContent(IEnumerable<(string Key, string Value)> items) {
            var output = "";
            foreach (var item in items) {
                output += $"\t\t{BuildConstVariable(item.Key, item.Value)}\n";
            }
            output += "\n";

            var dictionary = new StringBuilder();
            dictionary.AppendLine($"\t\tpublic static IEnumerable<string> All = new List<string>() {{");

            foreach (var item in items) {
                dictionary.AppendLine($"\t\t\t\"{item.Value}\",");
            }

            dictionary.AppendLine($"\t\t}};");
            output += dictionary.ToString();

            return output;
        }

        private static string GetSortingLayerClassContent(string[] labelsArray, int[] valuesArray) {
            var output = "";
            foreach (var label in labelsArray) {
                output += $"\t\t{BuildConstVariable(label)}\n";
            }
            output += "\n";

            var dictionary = new StringBuilder();
            dictionary.AppendLine($"\t\tpublic static Dictionary<int, string> All = new Dictionary<int, string>() {{");


            int idx = 0;
            foreach (var label in labelsArray) {
                output += $"\t\tpublic const int {ToUpperCaseWithUnderscores(label)}_INT = {valuesArray[idx]};\n";
                dictionary.AppendLine($"\t\t\t{{  {valuesArray[idx]} ,\"{label}\" }},");
                idx++;
            }

            dictionary.AppendLine($"\t\t}};");
            output += dictionary.ToString();

            return output;
        }

        private static string GetLayerClassContent(string[] labelsArray) {
            var output = "";
            foreach (var label in labelsArray) {
                output += $"\t\t{BuildConstVariable(label)}\n";
            }
            output += "\n";

            var dictionary = new StringBuilder();
            dictionary.AppendLine($"\t\tpublic static Dictionary<int, string> All = new Dictionary<int, string>() {{");

            foreach (var label in labelsArray) {
                output += $"\t\tpublic const int {ToUpperCaseWithUnderscores(label)}_INT = {LayerMask.NameToLayer(label)};\n";
                dictionary.AppendLine($"\t\t\t{{  {LayerMask.NameToLayer(label)} ,\"{label}\" }},");
            }

            dictionary.AppendLine($"\t\t}};");
            output += dictionary.ToString();
            return output;
        }

        private static string BuildConstVariable(string varName, string varValue = null) {
            return $"public const string {ToUpperCaseWithUnderscores(varName)} = \"{(varValue ?? varName)}\";";
        }

        private static string ToUpperCaseWithUnderscores(string input) {
            while (Regex.IsMatch(input, @"^\d")) {
                input = Regex.Replace(input, @"^\d", string.Empty);
            }
            return Regex.Replace(input, @"[^\w\d]", string.Empty).ToUpper();
        }

        private static byte[] GetHash(string inputString) {
            using (var algorithm = SHA256.Create())
                return algorithm.ComputeHash(Encoding.UTF8.GetBytes(inputString));
        }

        private static string GetHashString(string inputString) {
            var sb = new StringBuilder();
            foreach (var b in GetHash($"{GetNamespace()}{inputString}{FOLDER_LOCATION}"))
                sb.Append(b.ToString("X2"));

            return sb.ToString();
        }

        private static string GetHashFromSourceFile(string sourceFilePath) {
            if (File.Exists(sourceFilePath)) {
                var contents = File.ReadAllText(sourceFilePath);
                if (contents.Contains("// Content hash: ")) {
                    var hashStart = contents.IndexOf("// Content hash: ") + "// Content hash: ".Length;
                    var hashEnd = contents.IndexOf("\n", hashStart);
                    var hash = contents.Substring(hashStart, hashEnd - hashStart);
                    return hash;
                }
            }
            return String.Empty;
        }
    }
}
